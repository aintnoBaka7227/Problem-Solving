# this is a log book for week 7
# this week focus is greedy algorithm. If there are more times, look back on recursion, backtracking, dynamic programming

PrefixFreeSets problem:
Initial thoughts: I am using Brute Force and Greedy to solve this problem. I will use a nested for loop, the outer will loop through 
each string, while the inner will loop through every string and check if whether two strings with different indexes are prefix of the other,
if yes count - 1 (count is set to input array length for each outer loop). At the end of each outer loop, the count is stored in a vector.
Then I sort the vector and return the smallest value.

TroubleShootings:
Trial 1: It failed. My logic was incorrect as sorting the result won't give me the number of words that appear in all combinations. I tried 
another approach where first I use set to delete all duplicated words. Then I still use the same for loop, but track if each word can be 
a prefix of another word, and store in a vector. At the end, I count all 0 appears in the vector and return it.

Reflections: I misjudge this problem. I only use Brute force at the end. I wonder if there is any greedy approach to reduce computational time. 
The only thing I can improve is to break the inner for loop whenever the flag is reset to true. this is not a hard problem but the tricky part 
might be to find all words that are not prefix of others.

TaliluluCoffee problem:
Initial thoughts: this is a greedy problem.Since the time t increment overtime, the best straegy is to let the customer with largest index upfront
and descending to customer 1. I will sort the tip array in ascending order and loop over it, calculate tip[i] - t each loop and add sum.

TroubleShootings:
Trial 1: nothing need to be fix.

Reflections: This question is rather easy and a typical question for greedy algorithm.

LostParentheses problem:
Initial thoughts: This might be a greedy problem. I am not sure if it is correct but starting from the first "-", all following numbers will be minus
so my approach is to add all numbers before the first "-" and then minus all

TroubleShootings: 
Trial 1: it worked. nothing to change.

Reflections: Greedy work. This is just a trick question, where you realize that every nums after the '-' sign can be put into a Parentheses. I just need
to remember how to use string stream for future exams.

ShipBoxes problem:
Initial thoughts: My idea is to check all possible permutations of dimensions for each box. Let say x y z are the dimensions of box1, a b c are dimensions of
box2. For each permutation, I check the max value of x and a, y and b to get the first two dimension of the big box. This can be done in a nested for loop.
For the depth, it will be the sum of the other two dimensions of both box. The final price is the smallest possible. This approach is Brute force. 

TroubleShootings:
Trial 1: 




