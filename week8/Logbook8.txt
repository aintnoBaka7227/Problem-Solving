this is a logbook for week 8 
the aim for this week is to focus on solving problems using divide and conquer 

MatchNumberEasy problem:
Initial thoughts: This can be done by tracking each possible digit and calculate remained matches. by doing this, all cases can be covered. This can be done recursively,
and each calculated max_num will be stored in a map based on its length, and updated regularly after each recursive return.

Troubleshootings: 
Trial 1: My logic based on comparisons in length. Which means the return longer string is the largest. However, this cause bias as I did not remove trailing zeros,
which lead to cases like "000000" become the largest rather than numbers like "20".  

Reflections: this is not a hard problem as we can recursively track every single digits. However, I believe the problem can also be solved in a more systematic way
using dynamic programming as the duplicated steps can be represented as a ladder. I will try to using dynamic approach to resolve this problem if I have enough time.

HandsShaking problem:
Initial thoughts: Since the constraint is not too wide, divide and conquer may work. I also notice that since it is a circle, we need to pick one person 
as a flag, and start counting the based on the the remain groups on the left and right. If you choose a person k to shake hands, then we have a group of k-2 
in the left and a group of n-k in the right. And keep doing that till everybody shake hands. This also make sure no cross shake is allowed. This seems like 
a divide and conquer problem. 

Troubleshootings: 
Trial 1: I failed to recognize that when i seperate groups, this create two seperate subproblems rather, so I need to multiply the result from the rest, rather 
than adding them together.

Trial 2: I miss the case n = 0; since in the recursive function, without defining base case n=0 and return 1, I will miss the cases where there is no people left.

Trial 3: Seems like the time limit was not met. This may due to duplicated calculations. I will try applying memoization.  

Reflections: Appling memoization helps reduce calculation steps and made the limit time requirments. It tackles the problems of divide and conquer where duplicated
calculations lead to time deficiency. 

CorporationSalary problem: 
Initial thoughts: This might be done using bruteforce. I can loop thorugh each rows, calculating the salary of each employee by adding the salaries of surbodinates.
If this employee has no surbodinates then the salary will be 1 

Troubleshootings: 
Trial 1: My logic is incorrect. If I do it like this, I need to find the employee with no surbodinates first. I change my approach to Memoization + recursion. This 
way, I can pick any employees and calculate the salary recursive as it will trace back to the one with no surbodinates, which will be equal to 1

Reflections: It worked. However, I am solving this problem using memoization rather than Divide and Conquer. I will try to implement the solutions with Divide and 
Conquer later if there is more time. 

ProblemsToSolve problem: 
Initial thougts: This can be solved using Greedy approach. We can use nested for loop to check pairs that has a gap >= variety, with the outer loop work as a pivot.
And rather than go brute force to check all pairs, if there is any possible pairs found, we can break the outer loop immediately, as any possible pairs in the future
will always have a larger gap.

Troubleshootings: 
Trial 1: It work properly so nothing gone wrong.

Reflections: This is definitely a greedy problem. The tricky part is how to calculate the min number of problems by going from the first problem to the jth ones, and
then calculate the min probs taken to go from jth to ith. Moreover, implementing the loop by picking a pivot in the outer loop help decrease the total number of cases
needed to check

Weekly Digest: My plan was to practice divide and conquer. However, beside from Handshaking problem, I mostly solved all problems using memoization and recursion. 
There was one intering question where I work on Greedy approach, which is something I like the most, but not my target for this week. I will try to retake all questions
using Divide and Conquer in the future to practice for the exam.

