this is a logbook for week 8 
the aim for this week is to focus on solving problems using divide and conquer 

MatchNumberEasy problem:
Initial thoughts: This can be done by tracking each possible digit and calculate remained matches. by doing this, all cases can be covered. This can be done recursively,
and each calculated max_num will be stored in a map based on its length, and updated regularly after each recursive return.

Troubleshootings: 
Trial 1: My logic based on comparisons in length. Which means the return longer string is the largest. However, this cause bias as I did not remove trailing zeros,
which lead to cases like "000000" become the largest rather than numbers like "20".  

Reflections: this is not a hard problem as we can recursively track every single digits. However, I believe the problem can also be solved in a more systematic way
using dynamic programming as the duplicated steps can be represented as a ladder. I will try to using dynamic approach to resolve this problem if I have enough time.

HandsShaking problem:
Initial thoughts: Since the constraint is not too wide, divide and conquer may work. I also notice that since it is a circle, we need to pick one person 
as a flag, and start counting the based on the the remain groups on the left and right. If you choose a person k to shake hands, then we have a group of k-2 
in the left and a group of n-k in the right. And keep doing that till everybody shake hands. This also make sure no cross shake is allowed. This seems like 
a divide and conquer problem. 

Troubleshootings: 
Trial 1: I failed to recognize that when i seperate groups, this create two seperate subproblems rather, so I need to multiply the result from the rest, rather 
than adding them together.

Trial 2: I miss the case n = 0; since in the recursive function, without defining base case n=0 and return 1, I will miss the cases where there is no people left.

Trial 3: Seems like the time limit was not met. This may due to duplicated calculations. I will try applying memoization.  

Reflections: Appling memoization helps reduce calculation steps and made the limit time requirments. It tackles the problems of divide and conquer where duplicated
calculations lead to time deficiency. 

CorporationSalary problem: 
Initial thoughts: This might be done using bruteforce. I can loop thorugh each rows, calculating the salary of each employee by adding the salaries of surbodinates.
If this employee has no surbodinates then the salary will be 1 

Troubleshootings: 
Trial 1: My logic is incorrect. If I do it like this, I need to find the employee with no surbodinates first. I change my approach to Memoization + recursion. This 
way, I can pick any employees and calculate the salary recursive as it will trace back to the one with no surbodinates, which will be equal to 1

Reflections: 

