# this is a log book for week 3
# Quote of the day: If the code is not broken, don't touch it lol.

For this week, I want to practice using recursive approach to solve problems. However, if I can not solve it using recursion, I may find other approaches.

FracCount problem:

Initial thought: this problem can be solved using recursion. I can create another private function that take 3 parameters: int numerator, int denominator
and int count. count is used to count the position and initialized as 1. My base case will be 1/2 and return count immediately. If not I used a while loop
to check if there are any irreducable fractions with the denominator value. This can be check by using gcd(). If yes, increment count by one. At the end I 
return the recursive funcition with new count, decremented denominator and new numerator with value == the largest possible value based on the returned 
denominator.

Reflection: It worked, and since I count not find any better approach, I will stick with my solution here. I wonder if there is better way to use recursion
without having to implement any code inside my private function.


StrangeComputer problem:

Initial thought: This can be done using both brute force and recursion. But I will try recursion. One thing I notice is that the minimum number of operations
needed is equal to number of times the char in mem change between 0 and 1. I can create another private function takes 3 parameters: string mem, char c and 
int count. count is used to track number of changes, c to track the most recent char while mem will be updated each time the recursive function is recalled, 
removed the first character.

Reflection: Well it worked. I optimized it before submission so I don't think I need to improve anything for this one. Tried my best to reduce any steps 
that look unnecessary. 

SimpleCompressor problem:

Initial thought: Again this is a recursion problem. My idea for now is to using find() to navigate the [] for each recursion calls and uncompress it. Base
case is no square brackets found. Rather than open it from outside in, It is better to open it inside out, starting from most inner loop so that there is 
only one [] to handle. Multiple [] makes me feel hard to handle them.

Reflection: I did not know how to use rfind() till now. Still forgot how to use substr and find, which is not good at all. Got into some problems with Gradescope 
submission... Can't resolve it so I may try another problem for now. Very Frustrating.
I realized that my code might not passed due to test case where there is >= 2 compressions. If this is the case then my approach was totally wrong. I will try to 
change my approach. I am thinking of splitting the data string into substrings of independent chars and compressions. This way I can still create a private function
that handle each compression seperately. This is also helping me save times as I don't have to rewrite my logic. 

P/s: I still failed to get score on gradescope. Might switch to another one for now. I reliezed that my approach is wrong as it can only solved 1 compressions each,
not multiple compressions inside one compression like [2[3A][4B]]. It results in infinite loops, cause the program to break and Gradescope won't accept it.


FewestFactor problem:
Initial thought: Im thinking of using backtracking and recursion to generate all possible permutations of the array. For example [1,2,3], I can have 123 and backtrack
to 132, then backtrack to 1 and get 213, and do the same thing to get 231. This way I can cover all possible permutations. Then I can keep track of the num of factors
and the permutation itself, and compare it to the next permutation to get the final result. This can be done by having a private function that takes 3 parameters: 
digits array, index: track the current index of the digit for backtracking, and len: index of the last elements. 

Reflection: ... Well for now it works. One thing to consider is that there might be permutations that are similar to each other. My recursive for now will generate all
without conisder repititions. One way to resolve this is using Dynamic Programming. However, if I tried to merge it into my code using std::map, for every single 
Permutation it need to loop thorugh the map. Maybe unordered_map will be better? I will try it if I still have enough time. For now, leave it be. To sum up, the idea is
to generate all possible nums through backtracking and recursive call, then find the one with least factors (mathematics). 


QuickSums problem:

Initial thought: I can see similar pattern between FewestFactor problem and this one. I can use recursive backtracking to get all potential additions. For example, 
[1, 2, 3], we can have 1 + 2 + 3, backtrack to 1 + 23, backtrack to  12 + 3, backtrack to 123. This can be done through a private function that take the default parameters with
extra parameters as following: index: track the position of digit for backtracking, count: number of subnums generated, current: count the sum of subnums. 
base case is when index == size of the array, which means the recursive call reach the end of the array. If the calculated sum equal to the target sum then return
count - 1 as number of + is less than 1. Else return -1. Also for each backtrack call, it will return a result. comparing this result with the base result and get the
minimum.

reflection: Seems like it worked. For this problem it tooked me less time to do compare to FewestFactor. While the approach is still backtracking, for this one the index
is slightly different since for this one we calculated continous sums, not generating numbers, so the index will move based on the change of i in for loop. Moreover,
I am not sure but maybe dynamic programming can be applied to reduce computational cost, since there might be cases that are repititive. 


Weekly digest:
This has been a horrible week for me, as I did extremly bad in the exam. I tried B1 but I misinterpreted the question, lead to wrong approach and wrong ideas. got 47.5 
which was crazy for me. This is why i dicided to practice recursion, both brute force and backtracking. Even though this was week 3 ques, many can be solved by 
backtracking. I did look up example code of backtracking online to understand how to implement it, since ideas about backtracking is easy to be found, but hard to implement.

