# this is a log book for week 3

For this week, I want to practice using recursive approach to solve problems. However, if I can not solve it using recursion, I may find other approaches.

FracCount problem:

Initial thought: this problem can be solved using recursion. I can create another private function that take 3 parameters: int numerator, int denominator
and int count. count is used to count the position and initialized as 1. My base case will be 1/2 and return count immediately. If not I used a while loop
to check if there are any irreducable fractions with the denominator value. This can be check by using gcd(). If yes, increment count by one. At the end I 
return the recursive funcition with new count, decremented denominator and new numerator with value == the largest possible value based on the returned 
denominator.

Reflection: It worked, and since I count not find any better approach, I will stick with my solution here. I wonder if there is better way to use recursion
without having to implement any code inside my private function.


StrangeComputer problem:

Initial thought: This can be done using both brute force and recursion. But I will try recursion. One thing I notice is that the minimum number of operations
needed is equal to number of times the char in mem change between 0 and 1. I can create another private function takes 3 parameters: string mem, char c and 
int count. count is used to track number of changes, c to track the most recent char while mem will be updated each time the recursive function is recalled, 
removed the first character.

Reflection: Well it worked. I optimized it before submission so I don't think I need to improve anything for this one. Tried my best to reduce any steps 
that look unnecessary. 

SimpleCompressor problem:

Initial thought: Again this is a recursion problem. My idea for now is to using find() to navigate the [] for each recursion calls and uncompress it. Base
case is no square brackets found. Rather than open it from outside in, It is better to open it inside out, starting from most inner loop so that there is 
only one [] to handle. Multiple [] makes me feel hard to handle them.

Reflection: I did not know how to use rfind() till now. Still forgot how to use substr and find, which is not good at all. Got into some problems with Gradescope 
submission... Can't resolve it so I may try another problem for now. Very Frustrating.
I realized that my code might not passed due to test case where there is >= 2 compressions. If this is the case then my approach was totally wrong. I will try to 
change my approach. I am thinking of splitting the data string into substrings of independent chars and compressions. This way I can still create a private function
that handle each compression seperately. This is also helping me save times as I don't have to rewrite my logic. 

P/s: I still failed to get score on gradescope. Might switch to another one for now.


QuickSums problem:

initial thought: nothing, just for testing.

reflection: ...
