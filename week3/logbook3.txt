# this is a log book for week 3

For this week, I want to practice using recursive approach to solve problems. However, if I can not solve it using recursion, I may find other approaches.

FracCount problem:

Initial thought: this problem can be solved using recursion. I can create another private function that take 3 parameters: int numerator, int denominator
and int count. count is used to count the position and initialized as 1. My base case will be 1/2 and return count immediately. If not I used a while loop
to check if there are any irreducable fractions with the denominator value. This can be check by using gcd(). If yes, increment count by one. At the end I 
return the recursive funcition with new count, decremented denominator and new numerator with value == the largest possible value based on the returned 
denominator.

Reflection: It worked, and since I count not find any better approach, I will stick with my solution here. I wonder if there is better way to use recursion
without having to implement any code inside my private function.


StrangeComputer problem:
Initial thought: This can be done using both brute force and recursion. But I will try recursion. One thing I notice is that the minimum number of operations
needed is equal to number of times the char in mem change between 0 and 1. I can create another private function takes 3 parameters: string mem, char c and 
int count. count is used to track number of changes, c to track the most recent char while mem will be updated each time the recursive function is recalled, 
removed the first character.

Reflection: Well it worked. I optimized it before submission so I don't think I need to improve anything for this one:). Tried my best to reduce any steps 
that look unnecessary. 

