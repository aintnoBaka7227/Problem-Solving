# this is a log book for week 10
# this week focus will be graph but also look back on dynamic programming if possible

BridgeSort problem:
Initial thoughts: This problem can be solved using brute force. I can loop and sort the hand string based on the suit. This can be done using bubble sort. 
Then if two consecutive suit is similar, I can just check the values of them and swap if the next card value is smaller than the current card value. 

TroubleShootings: 
Trial 1: Nothing crucial to fix. 

Reflections: Brute force worked. However, using a faster sort algorithm like merge sort will improve time complexity. I will try to implement it later if I have enough
time. 

FoxAndMountainEasy problem:
Initial thoughts: I felt like this one can be solved by recursively tracking all possible moves and check the return result with the history string. However, since
we don't have to care about how many possible solutions we can get, we care more about if a possible solution with a substring similar to history string exists.
So I think this one can be solved using math approach. Since the substring can be anywhere, I can calculate the current height after each move in the history. 
If the height < 0 then I need to set it back to 0, cost 1 move. so I can use a var to track that. Then I can calculate the remain height and remain number of 
moves. If the number of move < remain height then it is a NO. 

TroubleShootings: 
Trial 1: I failed test case 3, 5. After a while, I realized that my condition for NO was lacking. If the remain height is even, I will need an even number of moves for it
and vice versa. 

Trial 2: looked like it worked.

Reflections: Another reasons why I thoughts this one should not be solved by checking all possible cases is because we also don't need to care about how many 
combinations will work. The order of moves in history also doesn't matter. I hope the during final exams the question will be similar cause I like math problem. 
But I will try implement the solution using backtracking approach in case questions in the final ask me to produce all possible moves. 

DengklekBuildingRoads problems:
Initial thoughts: After a few tries, I saw some patterns: 
(1, 2)
(1, 3), (2, 3)
(1, 4), (2, 4), (3, 4)
...
(i-K, i), (i-K+1, i), ..., (i-1, i)
This looks like a dynamic programming problem, we also need to track if the number of road to the current house is odd or even, and we only need to track 
from i-k to i since node from 1 to i-K-1 will not be considered due to the constrain K, so they won't be affected. Also when we move to i+1, we just need
to pass along the state where i-K is even. To track all of this, I create a dp table [i][j][k][bit] to track the house number, the remaining number of roads,
the current gap between two houses (to compare with K) and a dimension to track odd, even of k+1 houses in the range (using bit for convenience) since the state 
will change containuously for each house. This table is large enough to cover all cases from house i-k+1 to i. bit track parity of houses i-k to i. 
For the particular case where k= K-1, we need to see whether connect the current house i with the furthest house is possible, if the current house is odd then a 
road can not be built, and we set it to 0, else then it is possible to build a road and we won't need to track the parity for the furthest house any more, right-shift the bit
For k < K-1, we still consider more houses, so we handle the transition state as mentioned above, = [i][j+1][k][bit] where we increment number of edges by 1 but remain
the current state. 
After this, to consider adding a road to the current pair of house i-(k+1) , i. If j > 0, mean there is still more edges to use, so we update [i][j][k][bit] by adding
dp[i][j - 1][k] while the bit is also updated since we also add a new house i-(k+1) to consideration, and we also need to flip the bit of all houses in consideration
bit ^ (1 << (k + 1)) ^ (1 << 0)

Trial 1: it failed some cases and I realized there was overflown issues with the dp table, so I added a modulo MOD like the description and take the module of the 
dp value. It worked!

Reflection: this problem is the hardest one I have ever tried. I could not implement the solution by myself, need to read the source code and comments of previous 
posts related to this problem. The idea of using bit to handle continous switch between odd and even was brilliant. I learnt a lot from using this, and using ^ to flip
the bit. However, if I have to implement solution like this in the exam, with my current ability, I won't be able to handle it. The solution might look simple, but
the amount of time behind it was massive. 



