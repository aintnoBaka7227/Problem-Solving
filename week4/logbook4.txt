# this is a log book for week 4
# target for this week is recursion(brute force || back-tracking). However, if there are better design approaches then I will use them.

ImportantTasks problem:

Initial thoughts: This can be solved using brute force and greedy. I can sort both arrays in ascending orders and loop through the complexity array.
For each index in complexity array, I check with the corresponding position in computers array, if the computers can handle it then I moved
on to the next complexity, if not then I move the index by one in computers array to check if there is a computer that can handle the task.
If found then increment the count by one. This process will stop at the moment when one complexity is over the complexity that all available
computers can handle.

Reflections: first bug: out of bound access after my while loop. fixed by adding condition to check if loop to the end of computers array. This 
problem is quite straight foward and using greedy will be the best approach. Since both array is sorted, if there is one complexity that can not
solved by any comps, we will stop checking immediately since the following complexities will also not be solved anyways.

TimeTravellingCellar problem:

Initial thoughts: I am thinking of finding the cell the largest profit value then find the cell with the smallest decay (not the same index). May call
this greedy approach. Calculate the actual profit and return it. 
P/s: There is a hole in my solution. Finding the maximum and following minimum does not guarantee that the substraction will be the smallest or
a valid answer (>0). I changed my solution to calculating all possible substractions for each cellar in profit and each cellar in decay and keep track
the largest possible profit. This is brute force.

Reflection: Well it worked. However, it is quite a time consuming and costly approach since I have to calculate everything. If I had more time, I would 
come back and try recusion back tracking. One way to optimize my approach is  to still looping through every cell in profit, and find the minimum decay 
value (not the same index) for subtraction to minimize the computational cost. 

UnsealTheSafe problem:

Initial thoughts: This is definitely a recursive back tracking problem. For each input N, we will construct all posible safe's passwords base on the rules
which will have N layers. For each layer, we have an array of possible choices, which means after we count all possible choices in the last layer, we back
track to one level above and start checking all possible values again. This cycle continues till all layer at the top are choosen. My approach is to 
create a variable "result" to track number of passwords and a private function that take N, an array of next possible buttons, and an index to count the 
password length. Each time index == N, increment result by one. One funny thing is that since 25 is too big, my laptop took too long to run and it seized
at the end so I can't really check the result for 25. My laptop can only run the code with N <= 20.

P/s 1: since autograder can't run it. I will try long long. It doesn't work. It seems that my computational time is over the limit and gradescope seized.
I believed my approach is correct but it seems like it is taking too long to compute. I thought It would only be the case for my laptopn but seems like
It costed too much resources that seized the machine. I will try using dynamic programming to store value and see if it work or not. 
P/s 2: There are two base case length 0 and length 1 password. While length 0 does not really make sense, all possible value should be set to 0.
For length 1, there is 10 digits to choose so there are 10 choices. For N = 2, I realize that if it ends with 1 then the only way to reach it is from 2
and 4. so the number of length 2 password end with 1 is equal to number of length 1 password end with 2 + number of length 1 password end with 4, which
result in 2. The same logic goes on with N = 3, N = 4. Which result in the following equation: number of length N password end with digit a = sum of 
numbers of length N-1 passwords end with digits that will reach to a. To track all calculated number of passwords with length from 0 to N, I can create a table
that has N+1 rows and 10 columns from 0 to 9 which represents the last digit.  

Reflections: Since Ms Izu mentioned that UnsealTheSafe can be solved using Dynamic Programming, I tried it. I did some researches online on examples of 
Dynamic programming implementation, before trying on this problem again. I still believed that we can solve this problem using backtracking, but maybe
it needed to be implement with dynamic programming to decrease computational costs. I will try this approach again if there is still enough time.



