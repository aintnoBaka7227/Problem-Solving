# this is a log book for week 4
# target for this week is recursion(brute force || back-tracking). However, if there are better design approaches then I will use them.

ImportantTasks problem:

Initial thoughts: This can be solved using brute force and greedy. I can sort both arrays in ascending orders and loop through the complexity array.
For each index in complexity array, I check with the corresponding position in computers array, if the computers can handle it then I moved
on to the next complexity, if not then I move the index by one in computers array to check if there is a computer that can handle the task.
If found then increment the count by one. This process will stop at the moment when one complexity is over the complexity that all available
computers can handle.

Reflections: first bug: out of bound access after my while loop. fixed by adding condition to check if loop to the end of computers array. This 
problem is quite straight foward and using greedy will be the best approach. Since both array is sorted, if there is one complexity that can not
solved by any comps, we will stop checking immediately since the following complexities will also not be solved anyways.

TimeTravellingCellar problem:

Initial thoughts: I am thinking of finding the cell the largest profit value then find the cell with the smallest decay (not the same index). May call
this greedy approach. Calculate the actual profit and return it. 
P/s: There is a hole in my solution. Finding the maximum and following minimum does not guarantee that the substraction will be the smallest or
a valid answer (>0). I changed my solution to calculating all possible substractions for each cellar in profit and each cellar in decay and keep track
the largest possible profit. This is brute force.

Reflection: Well it worked. However, it is quite a time consuming and costly approach since I have to calculate everything. If I had more time, I would 
come back and try recusion back tracking. One way to optimize my approach is  to still looping through every cell in profit, and find the minimum decay 
value (not the same index) for subtraction to minimize the computational cost. 

UnsealTheSafe problem:
Initial thoughts: This is definitely a recursive back tracking problem. For each input N, we will construct all posible safe's passwords base on the rules
which will have N layers. For each layer, we have an array of possible choices, which means after we count all possible choices in the last layer, we back
track to one level above and start checking all possible values again. This cycle continues till all layer at the top are choosen. My approach is to 
create a variable "result" to track number of passwords and a private function that take N, an array of next possible buttons, and an index to count the 
password length. Each time index == N, increment result by one. One funny thing is that since 25 is too big, my laptop took too long to run and it seized
at the end so I can't really check the result for 25. My laptop can only run the code with N <= 20.

P/s: since autograder can't run it. I will try long long.

Reflections:

