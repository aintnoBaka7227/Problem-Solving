// this is a log book for week 9
This week focus is on designing graph solution

RoughStrings problem:
Initial thought: This might be a greedy problem. My idea is to find the most and least frequent letters and set the initial roughness. This can be done by using a 
map to get the occurences, push in a vector and sort. Then using a while loop, I first check if the least occurences <= n, I deleted the letter update new n and roughness. 
If not, then I will delete the max frequence letter one by one, and sort the array again and recalculate the roughness, decrement n by 1.

TroubleShootings: 
Trial 1: I failed cases that are contradicted to the evil cases where there are multiple least values and n is largest than the sum of them. I fixed it by counting 
the sum of these least value and check if n is larger than them. if yes then execute the part to delete least occurences. 

Trial 2: I failed again with the test case contradicted to the previous one, where the condition is met but it is still beneficial to decrement the largest rather 
than delete all similar least frequent. My current approach will not be able to cover all cases. I changed my approach to a more brute force one, where I will 
try to cover all ranges of least-most frequent by using a nested for loop. This way I can cover all possible roughness that can appear, and calculate the cost of
removing by comparing each frequence with the range, if it is outside the range then I add the difference to the cost. 

Trial 3: I failed some cases due to my range did not include the most frequence value. I changed the code to have it.

Reflections: This problem costed me too much time. Mostly due to my Greedy approach did not cover all cases. However, I believe it is faster than my new Brute Force one, as 
for the new one, i need to check everys single possible case, which many of them may not even need to check. I will try to reimplement my old solution if I have more time.

SentenceDecomposition problem:
Initial thoughts: This problem can be solve using Recursion. I can manually check if each valid words exists in the sentence by taking the substring with the same length
and use sort to check if they contain same letters. Then i can try to calculate the min total transformation costs. After one is found, I can call the recursive function again 
to find the rest. each substring after computation will be saved in a map to reuse again if the same string appear multiple times. This is to handle cases like "three, there"

TroubleShootings: 
Trial 1: Got into some problems with word checking to see if there is any matches between valid words and substring of the input sentence. However, I searched online
and know that we can use sort() to check if they contain similar letter. 

Trial 2: Did not check if the sentence string is long enough to take a substring out of it, lead to failure in case 5. Update the recursive function to check this condition.

Trial 3: Got overflown due to using INT_MAX for cost comparision. change to a big enough num -> seem to work.

Reflections: 
