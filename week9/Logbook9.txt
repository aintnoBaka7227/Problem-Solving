// this is a log book for week 9
This week focus is on designing graph solution

RoughStrings problem:
Initial thought: This might be a greedy problem. My idea is to find the most and least frequent letters and set the initial roughness. This can be done by using a 
map to get the occurences, push in a vector and sort. Then using a while loop, I first check if the least occurences <= n, I deleted the letter update new n and roughness. 
If not, then I will delete the max frequence letter one by one, and sort the array again and recalculate the roughness, decrement n by 1.

TroubleShootings: 
Trial 1: I failed cases that are contradicted to the evil cases where there are multiple least values and n is largest than the sum of them. I fixed it by counting 
the sum of these least value and check if n is larger than them. if yes then execute the part to delete least occurences. 

Trial 2: I failed again with the test case contradicted to the previous one, where the condition is met but it is still beneficial to decrement the largest rather 
than delete all similar least frequent. My current approach will not be able to cover all cases. I changed my approach to a more brute force one, where I will 
try to cover all ranges of least-most frequent by using a nested for loop. This way I can cover all possible roughness that can appear, and calculate the cost of
removing by comparing each frequence with the range, if it is outside the range then I add the difference to the cost. 

Trial 3: I failed some cases due to my range did not include the most frequence value. I changed the code to have it.

Reflections: This problem costed me too much time. Mostly due to my Greedy approach did not cover all cases. However, I believe it is faster than my new Brute Force one, as 
for the new one, i need to check everys single possible case, which many of them may not even need to check. I will try to reimplement my old solution if I have more time.

SentenceDecomposition problem:
Initial thoughts: This problem can be solve using Recursion. I can manually check if each valid words exists in the sentence by taking the substring with the same length
and use sort to check if they contain same letters. Then i can try to calculate the min total transformation costs. After one is found, I can call the recursive function again 
to find the rest. each substring after computation will be saved in a map to reuse again if the same string appear multiple times. This is to handle cases like "three, there"

TroubleShootings: 
Trial 1: Got into some problems with word checking to see if there is any matches between valid words and substring of the input sentence. However, I searched online
and know that we can use sort() to check if they contain similar letter. 

Trial 2: Did not check if the sentence string is long enough to take a substring out of it, lead to failure in case 5. Update the recursive function to check this condition.

Trial 3: Got overflown due to using INT_MAX for cost comparision. change to a big enough num -> seem to work.

Reflections: Now it worked. I still wonder why INT_MAX does not work. However, this is a familiar question compare to probs I solved last week. With a little twist
where I need to check if two string contain similar letters. I will solve more questions using this method to prepare for my final. 

CellRemoval problem: 
Initial thoughts: Took me some time to understand the problem. This problem can be solved using Brute Force approach. I can create another array that contains all the CellRemoval
with a number to present its status (alive or dead) and mark the deleted cell as dead. Then I can use a nested loop, with the outer loop loop through each cell, and the inner loop
will trace back to parent nodes till the top root is reached. If any parent node is equal to the deletedone, mark the current node status as dead and break the loop. 

TroubleShootings: 
Trial 1: I miss the part where parent cells won't exist anymore if they are splited, so I also need to mark them as dead. 

Reflections: I tried to rewrite the nested for loop into a recursive function but it is not working. Another approach is to reconstruct the parent array into a binary three
and write down the function for tree deletion. I will try this approach if I have more time, cause my current logic to identify whether a cell is dead or not based on parent cell
is similar to deletion in tree. 


ErdosNumber problem:
Initial thoughts: This is definitely a graph problem. a graph contains all authors can be formed with authors in the same publications are connected to each other. This
can be done using adjacent lists or a 2d array. Then I need to calculate the erdos number for each author, based on the publications contains erdos, to calulate the erdos number
for the co authors, and then based on these authors to calculate erdos number further. For the output part, to sort the author name, I can use a set to store authors'names. 

To build a graph, I will implement adjacent lists by using an unordered map and set to implement the node for each author and connect the node with other coauthors.

To calculate erdos number for authors, this can be done using queue, pushing "ERDOS" first. For any coauthors, we will increment erdo nums by one, and keep spanning queue. 
Authors with erdo nums that are calculated will be pop out of the queue (first in first out). I can also use a map to store calculated authors' erdos number, since I don't want
to recalculate it twice

TroubleShootings: 
Trial 1: It worked! 

Reflections: This problem approach is not a tricky one since I understand graph. However, the part where I need to calculate erdo numbers was very time consuming, as I need 
to find the correct data structure that is efficient for finding coauthors and after all the coauthors are found and calculated, the author must be deleted. Queue seems to be 
the most suitable one. 

Weekly digest: There was only one problem that I can apply graph to solve it (ErdosNumber). However, spending time learning about the data structure was helpful, and working 
on the assignment pushed me to think on what data structures should be used for different purposes, which was something missing in weekly practices. I also refreshed my skills
on recursion and memoization working with RoughStrings and SentenceDecomposition. However, I would love to spend more time solving Graph problems, which was still lacking in this 
week practice. 

