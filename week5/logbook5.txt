# this is a log book for week 5

# this week is for dynamic programming. At least I need to solve 2 probs involves dynamic approach.

RunLengthDecoding problem:

Initial thoughts: Brute Force to core. My idea is to loop through the entire string, each time a number is encountered, I recorded the value and 
decode the correspond character based on that number. 1 while loop is used to handle the number and increment index. 

TroubleShootings: Got into problem with my implementation because of 
two reasons: 1. fix directly on text string -> unexpected behavior when for loop use text.length() as condition; 2. number can be up to two digits
but my implementation only check 1. How did I fix it: create another string called decoded_text. This string will add each letter if there is nothing
to decode, else it will add the decoded parts. Let see if it worked. Also if any decode part is > 50 then return immediately. Got into problem with 
using stoi for count when the num is too large -> change it to adding each digit into a variable name count. got into the same problem but with input
num even bigger: fixed by each time count is changed, see if count > 50 return immediately.

Reflection: This is a fast and easy approach. some might use recursion but I prefer this way. I need to be more careful when implement it as there are 
cases that I might potentially miss or fixing on provided parameters. Finally it is fixed, i missjudged the question as there were so many edge cases
could break my code.

SimpleDuplicateRemover:

Inital thoughts: seem like this is a dynamic programming question. For each encounter, if the num is new then add it to a table, if not then don't add
it. and when i loop through the array, I loop it backward so that the table will have a reverse order of the output table that only contains right-most
values. The table can be a vector.

TroubleShootings: There is no major problems.

Reflections: well it worked. However, one bad thing about my approach is that every single time i loop through the input array, I also have to reloop on 
my table to check if it is duplicated. Moreover, I need another method to reverse my vector table at the end, which is costly. I believe there must be 
a better approach that I haven't discover. I will redo it later with better approach if there is still time.


RGBStreet problem:
Initial thoughts: This problem can be solved using either backtracking or dynamic programming. Since we may need to calculate all possible cases when
we pick R, G, B for the first house, then we will need to pick between the other two colours with lowest price for the next house, and keep doing that 
till the last house. We can create a table with 3 rows, each rows will start will a different colour. There will be houses.size() + 1 column, with each 
column represent the total cost after n houses been painted. Since the way we calculate the price for the following houses duplicate, we can reuse those 
values for next calculation. for example if red is pick then the next house will be either green or blue with the lowest price, if the next house is blue 
then the following one will be either red or green, if we pick green then it will come back to red or blue and so on. By utilizing this fact, we can reuse 
the calculated value store in the table to reduce computational cost. 
pseudo code: row[i+1] = price(color1) + std::min(price(color2), price(color3))

TroubleShootings: There is no major problems.

Reflections: Seems like my approach works. I believe this is the optimal way (even though this problem is sifnified as an dynamic programming problem) Since
we reduce all duplicated calculations using a value table. If this problem is solved using backtracking, I might got into resource overflow like UnsealTheSafe,
where number of computations is enormous. One thing to remember from this is for dynamic programming problem, the requirements tend to be finding the maximum
or minimum values where all provided values are randomized, which require us to calculate all possible computions but these computations are duplicated. 
Another thing is using string stream to parse a string with delimeters. This is crucial to remember for future exams.


TomekPhone problem:
Initial thoughts: For now I don't really have any ideas. One thing I noticed is that we need to put letters with most frequencies first so that they only need
the minimal number of keystrokes while the less frequence ones should be put behind. This seems to be a greedy algorithm. I will sort the frequencies array in
ascending order. Then I can run a nested for loop, the outer is for tracking number of keystrokes needed for the character at n'th position while the inner for
loop is to loop throught the number of letters each key can contains. This way, we can assign all the most frequence chars for all keys in the first layer at
the same time, and then do it again for the following layers. However, doing it this way means that we don't really know the size of each key, so we need a limit
for number of loops in the outer for loop. Since each elements of keySizes is between 1 and 50, I will cap the for loop at 50. But this means there will be too
many for loops to check, which is inefficient so in the inner for loop, I will check if the size of each button being loop with the current index of the outer 
loop to reduce number of loops needed, and also by tracking on how many chars have been assigned, the number of for loop needed will also be reduced. For the base
case, I will calculate number of possible slots and return -1 if size of frequencies is bigger then number of slots.

TroubleShootings: There is no major problems.

Reflections: This problems look hard at first but it not really hard. The for loop logic was tricky cause normally, I will always loop through each value of keys
in keySizes array, and the inner loop will be the keystrokes. However, if doing that means I can only assign each char in one key at one time, which logically wrong
since what I want is to assigned all most-frequenct chars at the same time at any available keys. I am not sure if there are better solutions to this problem.
One thing about greedy is that I need to check all possible cases. If not then the logic might not be correct or bypass unseen cases, lead to failing points. 

Weekly dialog: My initial ideas for this week is to practice dynamic programmming. However, the only dynamic question so far is the bonus one, which has not been 
what i want. While the first and last questions I solved are either brute force or greedy question, which is not helpful. SimpleDuplicateRemover can be solved using
dynamic approach, and my solution did use it to a small extent, but I believed there are optimal ways of using dynamic programming for this question rather than my
way, cause it seems more brute force to me. I will try to do more dynamic programming questions and revise recursion (backtracking - brute force) next week to prepare
for the following exams.


