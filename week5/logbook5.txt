# this is a log book for week 5

# this week is for dynamic programming. At least I need to solve 2 probs involves dynamic approach.

RunLengthDecoding problem:

Initial thoughts: Brute Force to core. My idea is to loop through the entire string, each time a number is encountered, I recorded the value and 
decode the correspond character based on that number. 1 while loop is used to handle the number and increment index. 

TroubleShootings: Got into problem with my implementation because of 
two reasons: 1. fix directly on text string -> unexpected behavior when for loop use text.length() as condition; 2. number can be up to two digits
but my implementation only check 1. How did I fix it: create another string called decoded_text. This string will add each letter if there is nothing
to decode, else it will add the decoded parts. Let see if it worked. Also if any decode part is > 50 then return immediately. Got into problem with 
using stoi for count when the num is too large -> change it to adding each digit into a variable name count. got into the same problem but with input
num even bigger: fixed by each time count is changed, see if count > 50 return immediately.

Reflection: This is a fast and easy approach. some might use recursion but I prefer this way. I need to be more careful when implement it as there are 
cases that I might potentially miss or fixing on provided parameters. Finally it is fixed, i missjudged the question as there were so many edge cases
could break my code.

SimpleDuplicateRemover:

Inital thoughts: seem like this is a dynamic programming question. For each encounter, if the num is new then add it to a table, if not then don't add
it. and when i loop through the array, I loop it backward so that the table will have a reverse order of the output table that only contains right-most
values. The table can be a vector.

TroubleShootings:

Reflections: well it worked. However, one bad thing about my approach is that every single time i loop through the input array, I also have to reloop on 
my table to check if it is duplicated. Moreover, I need another method to reverse my vector table at the end, which is costly. I believe there must be 
a better approach that I haven't discover. I will redo it later with better approach if there is still time.


RGBStreet problem:
Initial thoughts: This problem can be solved using either backtracking or dynamic programming. Since we may need to calculate all possible cases when
we pick R, G, B for the first house, then we will need to pick between the other two colours with lowest price for the next house, and keep doing that 
till the last house. We can create a table with 3 rows, each rows will start will a different colour. There will be houses.size() + 1 column, with each 
column represent the total cost after n houses been painted. Since the way we calculate the price for the following houses duplicate, we can reuse those 
values for next calculation. for example if red is pick then the next house will be either green or blue with the lowest price, if the next house is blue 
then the following one will be either red or green, if we pick green then it will come back to red or blue and so on. By utilizing this fact, we can reuse 
the calculated value store in the table to reduce computational cost. 
pseudo code: row[i+1] = price(color1) + std::min(price(color2), price(color3))

TroubleShootings: 

Reflections: 

