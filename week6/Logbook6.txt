# this is a log book for week 6

Target for this week: practice dynamic programming and prepare for exam 2. Time limit is applied. I will track my time limit.

ColorfulRabbits problem: 
Initial thoughts: I noticed that if a replied value is unique then there will be value rabbits. If the replied value is zero then there
can only be 1 rabbit. If there are two similar replied value then the minimal number of rabbit will be value + 1. However, if there are more
than 2 replies that share the same value, each pair of replies will be consider a group of rabbit with same color and these pairs won't share 
the same color. There won't exist 3 replies with the same value that these mentioned rabbit will share the same color. I may use memoization
to store the each value and track of number of time each value appear. may be using an unorder map.

TroubleShootings: 
Trial 1: my logic was incorrect. If there is more than 2 replies that share the same value, then there can only be a maximum of value + 1 replies
that these replies will be considered as a group of rabbits with the same color. for example: 3 rabbits can reply "2" but not four. 

Reflections: After trial 1 i got it. This problem is straight bruteforce with little mathematics. However, I midjudge some cases which lead to 
failed result at first. It passed all the demo cases so it took me a while to realize my wrong logic. The main logic is when the number of rabbits
with the same color will always be value + 1 for all cases. If number of replies with the same value is over value + 1, it means there is a new 
group of rabbits with a different color which again has value + 1 rabbits. 

CountExpressions problem:
Initial thoughts: My approach for now is recursive backtracking as I need to check all possible arithmetic expressions of the provided two numbers
to compare with the target result. I will create another private funtion that take two input parameters, two new vars for counting number of times
each number appear(maximum 2 for each num) and one var to check the end result of each arithmetic expression. Since there is 3 arithmetic operators and 2 nums,
in public function the recursive function will be called twice while in private function, it will be called 3 times to cover all combinations.

TroubleShootings:
Trial 1: nothing gone wrong

Reflections: It worked. However I wonder if we can use dynamic programming for this problem as there are cases that duplicate others since elements
in the expressions just switch positions. If I can figure how each time an expression is valid, I can calculate all related expressions so that 
I don't have to recalculate them again. I will think about it another time.

NiceOrUgly problem:
Initial thoughts: This problem can be solved using backtracking or dynamic programming. 

TroubleShootings:
Trial 1:

Reflections:


