# this is a log book for week 6

Target for this week: practice dynamic programming and prepare for exam 2. Time limit is applied. I will track my time limit.

ColorfulRabbits problem: 
Initial thoughts: I noticed that if a replied value is unique then there will be value rabbits. If the replied value is zero then there
can only be 1 rabbit. If there are two similar replied value then the minimal number of rabbit will be value + 1. However, if there are more
than 2 replies that share the same value, each pair of replies will be consider a group of rabbit with same color and these pairs won't share 
the same color. There won't exist 3 replies with the same value that these mentioned rabbit will share the same color. I may use memoization
to store the each value and track of number of time each value appear. may be using an unorder map.

TroubleShootings: 
Trial 1: my logic was incorrect. If there is more than 2 replies that share the same value, then there can only be a maximum of value + 1 replies
that these replies will be considered as a group of rabbits with the same color. for example: 3 rabbits can reply "2" but not four. 

Reflections: After trial 1 i got it. This problem is straight bruteforce with little mathematics. However, I midjudge some cases which lead to 
failed result at first. It passed all the demo cases so it took me a while to realize my wrong logic. The main logic is when the number of rabbits
with the same color will always be value + 1 for all cases. If number of replies with the same value is over value + 1, it means there is a new 
group of rabbits with a different color which again has value + 1 rabbits. 

CountExpressions problem:
Initial thoughts: My approach for now is recursive backtracking as I need to check all possible arithmetic expressions of the provided two numbers
to compare with the target result. I will create another private funtion that take two input parameters, two new vars for counting number of times
each number appear(maximum 2 for each num) and one var to check the end result of each arithmetic expression. Since there is 3 arithmetic operators and 2 nums,
in public function the recursive function will be called twice while in private function, it will be called 3 times to cover all combinations.

TroubleShootings:
Trial 1: nothing gone wrong

Reflections: It worked. However I wonder if we can use dynamic programming for this problem as there are cases that duplicate others since elements
in the expressions just switch positions. If I can figure how each time an expression is valid, I can calculate all related expressions so that 
I don't have to recalculate them again. I will think about it another time.

NiceOrUgly problem:
Initial thoughts: This problem can be solved using recursion or dynamic programming. for now I only have an idea on using recursion. The index start from 
the start of the string, each time index move 1 I check whether if it is ?. if yes then both count for vowels and consonants increment, recursive call for each cases. 
if not then check if vowels or not. if vowels then count for vowel increment and reset count for consonanants and vice versa. While I know that I can optimized my recursion to 
reduce steps by also checking the following chars, for now I will play it safe.

TroubleShootings:
Trial 1: it got the right answers for all demos test case. But it seems like it did not pass the time limit for gradescope so it fails. I will try dynamic programming.
another problem is I was recalculating whenever I hit a ?, as my code duplicated when I check ? or uppercase chars so that might cause time and space inefficient.

Trial 2: For dynamic programming, my approach is similar as I create a dp table dp[51][4][6][2] to track current position in string, current number of consecutive
vowels, consonants and state: ugly or not. each time a valid position is hit (which is true), I will check if the current char is ? or not, and check the count of consecutive
vowels and consonants so far. If the condition is met, reset count of vowels and consonants based on conditions, and the next position based on the current one will be marked as true.

Trial 3: everything i fine for case where nice appears or 42 but for case on have ugly i failed. I found out that for nice I only need to check the last element
while for ugly, I need to check if ugly appear in anywhere inside the table.

Reflections: Again i got into the trap of duplication where recursion is not efficient anymore due to replicated calculations. What i realized is that every dp problems
start from recursion, but optimized to reuse calculations so that it won't be overflow. However, using dp is very hard.

JumpyNum problem:
Initial thoughts: I believe this problem can be solve using dynamic programming. I can see a similar soving pattern like UnsealTheSafe. For each jump number, starting from the
first digit, the number of digits can be used for the next digit is limited as the differ must be at least 2. so I can construct it like if it is 1, then the next one is in 
the range [3,9], for 2 then it is [4, 9] and 0 and so on. And the procedure to select the next digit in a jump number will be duplicated over time, which can be express using a formula
like dp[n][d] += dp[n-1][d] where n is the length of the jump num and d is the start. 
e.g: DP[2][1] += DP[1][3] + DP[1][4] + DP[1][5] + DP[1][6] + DP[1][7] + DP[1][8] + DP[1][9].
So with my dp table, i will count all posible cases, and compare the input values with the table to count the total number. Base on the requirements, my table will store till 
the length of 10. Another thing that I am not sure is how can since low and high can have different number of digits, I may need to split it into comparing all numbers that number
of digits is low and number of digits is equal to high.

TroubleShootings: 
Trial 1: I got into the problem where I need to check number of jump nums in [low, high]. At first I tried to count from low to the highest possible num with high.length - 1.
And then count the rest. However, this is insufficient because I have to resolve checking digits in both high and low, which is hard and time consuming. So I change it into
counting all jump nums from 1 to low, counting all jum nums from 1 to high, and take the differ between the former and latter for final result. This way I can create private function
to perform calculation and resuse it, and also only have to resolve the digit condition for the high rather than doing it twice include the low. 

Trial 2: I got into problem with the part where I count total number of jump num with equal number of digits compare to high in count function. In the for loop condition, I tried
d <= int(str_high[index] - '0') which was incorrect since it need to be strictly smaller than the current digit. I fixed that to <. Morever, in the inner for loop, I set 
count_high+=dp[str_high.length() - index + 1][d] which was also incorrect. I fixed it to str_high.length() - index. This is because to ensure the jump num always smaller than high,
when I tried to construct the jump num, I can only do it digit by digit, not just based entirely on the first digit. 

Reflections: Initializing dp table is not hard since I met it before. However, the part where I have to count number of jump nums based on high isvery hard to implement. If this question 
is in B part in the exam, I can confidently confirm that I won't be albe to do it in such time frame. My solution worked but I think there should be an optimized solution based on mine.
I need to calculate the entire table to the high of 2000000000, which is unecessary in most case. I should only calculate the table till the input high. I will try to improve my solution
before the exam.

Weekly dialog: All questions I attempted so far for this week were hard. Using dp is not my advantage, since I could not design the dp table in a shortamount of time. I will practice other 
questions to see if it improve. If not then to prepare for the exam, I may need to return to recursion and memoization to solve dp problem.
